\documentclass[letterpaper, 10pt]{article}
\usepackage[margin=1.0in]{geometry}
\usepackage{graphicx}
\usepackage{verbatim}

\begin{document}

% Title Page
\begin{titlepage}
	\centering	
	\includegraphics[width=6.50cm]{res/TSA-Emblem.png}
	\vspace{1.15cm}
	
	\scshape\Huge TSA Software Development \\
	\vspace{0.25cm}
	\scshape\LARGE National Conference -- Nashville, Tennessee \\
	\vspace{0.25cm}
	\scshape\LARGE June 28th - July 2nd, 2016 \\
	
	\vspace{1.55cm}
%	
	\mdseries\Large McKinney Boyd High School Chapter \\
	\vspace{0.25cm}
	\slshape\LARGE Sammy Shin, Trevor Nguyen, Christian Duffee \\
	\vspace{0.25cm}
	\scshape\LARGE Summer 2016 \\
\end{titlepage}

\cleardoublepage

\Large
\tableofcontents
\normalsize

\cleardoublepage

\section{Research}
	We focused our research on the topic of artificial neural networks (ANNs), which although relatively new grounds for our project team, ANNs is not a novel topic to academia. Several academic papers in computer science have been long since published about using ANNs in a variety of scenarios from analyzing partial derivatives to recognizing visual patterns. With an overview on the mechanisms of ANNs and the problems solved by them, we delved into the capabilities and limits of what ANNs could do in order to establish a deep understanding of their context in applications. We then spent the rest of our research on current implementation techniques which unsurprisingly required \emph{multiple} years of calculus. As difficult as it was rewarding, our research has culminated in a compilation of our findings below.
	\paragraph{The Artificial Neural Network}
		 The term \textbf{artificial neural network} refers to a data model which provides means to compute a set of outputs from a set of inputs which is specifically modeled after the \textbf{biological neural networks} present in animals. Biological neural pathways are based around impulses causing neurons to selectively fire after reaching a threshold. Whether a neuron will fire depends on multiple inputs of varying importance. When an active neuron fires, it stimulates the firing of other neurons further along the pathway. Computer scientists have likened this biological relationship to \textbf{weighted digraphs}, in which nodes represent neurons and are connected by unidirectional edges that have numerical weights associated with them. In ANNs, inputs are fed into one side of the digraph, and after series of abstract computations called \textbf{transfer functions}, outputs emerge on the other side. ANNs are, by nature, highly abstracted data models.
	\paragraph{Capability}
	ANNs are very good at pattern recognition because they are modeled off of the universe's most sophisticated decision making machine, the \emph{brain}. They have been able solve some of the most difficult problems with orders of magnitude more accuracy than more traditional algorithms. ANNs are used in \textbf{natural language processing}, \textbf{image identification}, \textbf{speech recognition}, \textbf{handwriting recognition}, and recently, playing Go. Despite their robustness, ANNs are limited by their need for extremely large data sets from which they extrapolate algorithms.
	\paragraph{Transfer Functions}
	When all of a node's input values are available for computation, the node runs what is called a transfer function, which will calculate that specific node's output value. Before the inputs are given to the transfer function, the inputs are often normalized using sigmoidal models. The transfer function takes a set of inputs and a set of corresponding weights as formal parameters and processes them with higher weighted inputs having more of an effect on the node's output. In addition to inputs, the transfer function also takes in a \textbf{threshold value} which will must be reached in order to have a signal propagate.
	\paragraph{Backward Propagation}
	Backward propagation is how ANNs adjust graph weights in order to improve network accuracy and reduce \textbf{systematic errors}. The network compares its outputs with the desired outputs in order to calculate that error. The partial derivative of the error is used to make numerical approximations on the error function's extrema, which is called in optimization studies \textbf{hill climbing}. Backward propagation starts from the end of the network and propagates the changes in the reverse direction to the input nodes by adjusting input weights. The output nodes propagate the error to their respective input nodes and the individual errors of the input nodes and subsequent adjustment is calculated mathematically.
	\paragraph{Parallel Computing and Process Synchronization}
	Both of these concepts crop up in the world of concurrency and are techniques in order to effectively use a programming language's concurrency capabilities to one's advantage. \textbf{Parallel computing} is the act of running computational processes at the same time on different program threads. The actual hardware processor may use its own algorithms to handle these low level task, which is normally going to be some derivative of round-robin scheduling. With many independent asynchronous processes running in parallel, the issue of \textbf{process synchronization} emerges, which is essentially the unification of multiple processes under the same time domain. This is something that we used in order to separate the graphical user interface from the ANN's mathematical computations in order to improve usability.
	
\cleardoublepage
\section{Description}
	\paragraph{Problem} The job of a software engineer is to maintain software code and to write algorithms to perform necessary operations on data while keeping in mind clarity, correctness, and efficiency. Being a software engineer is an example of a difficult job in high demand, requiring a very specific mindset and vast intellectual capability. Software engineers handle tasks at which ordinary people without the proper wherewithal would balk.
	
	Algorithms dominate the software engineering sphere. A large problem in applied computer science lies in humans thinking of, designing, and implementing algorithms in real software that can be run efficiently given hardware constraints. There is a large list of well-known algorithms that almost all computer scientists understand and study as part of their computer science degree, yet this list of algorithms that are studied is finite their immediate applications are limited. Known algorithms are efficient and used where possible, but when a problem requires an algorithm that has not yet been created, these well-known algorithms can only serve as a computer scientist's inspiration.
	
	Algorithm design for extremely esoteric scenarios can be time-consuming for software engineers, backing up the software design process, creating delays, and losing profits for a company. In short, algorithm design would be the major bottleneck for any sort of large software project. Too often, a company may sacrifice efficiency for speed of development, resulting in \emph{less-than-optimized} algorithms. The larger problem, however is coming up with algorithms for which it would be completely infeasible to design by hand.
	
	For example, if one were to design software for a distributed system of robots, one would have to write the decision making model for each one of these robots. However, one must keep in mind the greater scale of the system complete with group interactions and changing environments. Deep analysis is required to determining emergent behaviors as the scale becomes smaller, as well as attention to the larger aspect of things with large-scale integration and cooperation between individually functioning entities. To put things into perspective, in order to organize a mob with a size on the order of one thousand people, it would require a massive bureaucratic organization, but also if the case that activities do not go according to plan, a leader must step in to correct the situation. The software on the robots system would mirror the situation except no form of organization would be present; each robot would have to have the artificial intelligence to instinctively know how to react to the rest of the robots' actions. In addition to this mess of a problem, the software engineer would have to foresee potential issues in his or her own design in order to write alternate routines for situations in which an error has occurred.
	
	Not only in the field of autonomous robotics do these design challenges appear. To manually create an image recognition scrip would be almost impossible for a human alone to design. Simply put, the problem is that software engineers need an algorithm that will write algorithms -- code that writes code. To be precise and technical, what was just described would be metaprogramming. However, what is really needed is a program that will create, test, and refine an input/output-based algorithm, which is the primary advantage of neural networks. MATLAB has a neural network package available to purchase with their software. Many other neural network libraries are available to purchase. Such software solutions exist, but not all of them are available on every platform, nor are all of them simplistic and easy, yet effective at fulfilling their purpose. Java lacks popular \emph{native} libraries that have a short enough learning curve for a beginner to computer science could use, yet robust enough to be used for serious applications.
	\paragraph{Solution} Project Ecclesia aims to create a native Java library for artificial neural network that addresses current issues mentioned above. It will provide a framework for utilizing artificial neural networks in applications from year one student projects to refined industrial software. Not only will Ecclesia disseminate as an simple, yet powerful way to use neural networks, our project team intends for Ecclesia to be accessible to every developer at no cost under the MIT License by August 2016.
	
	We decided after the core of our project had been completed to name the culmination of our efforts Project Ecclesia. The name Ecclesia ($\varepsilon \kappa \kappa \lambda \eta \sigma i \alpha$) refers to the ancient Athenian democratic assembly, which we found highly appropriate because our program functions as a complex system for decision making. In addition, after Solon's reforms, the ecclesia became an assembly in which even the lowest ranks of society could participate. Aforementioned, Ecclesia will be available at no cost to developers as an openly sourced project. We like to think that the name is quite apt.
\clearpage
	\paragraph{Social and Educational Value} 
	Ecclesia will simplify the jobs of Java software engineers who are designing algorithms. It will allow Java software engineers to focus on the more important abstract details of software programming rather than getting caught up in the minutia of programming. As Project Ecclesia increases in popularity, more and more people will be familiar with how artificial neural networks function and professionals will use artificial neural networks increasingly in their software. Because Java is one of the industry's most ubiquitous programming language, Project Ecclesia could be a game changer and shift the focus of the software development toward the use of artificial intelligence using neural networks.
	
	Project Ecclesia can also be used as an educational tool in the classroom to teach young computer science students the beauty and magic of artificial neural networks. Experience using libraries written natively in Java used to supplement teaching will seriously enrich a computer science student's understanding of real applications of computer science concepts. Furthermore, the fact that our team chose to write the artificial neural network in very clean and efficient code that embodies the ideals of Java, using Ecclesia library to make artificial intelligence applications is also a great way to reinforce understanding use of object oriented principles.
	
	In addition to being used as a supplement to computer science education for experience using external Java libraries, Ecclesia is also able to offer an easy introduction to artificial intelligence for more advanced computer science students who are looking to move forward in computer science. A huge ideal in Project Ecclesia has been to make artificial neural networks simple and robust. It is easy to jump right into using it for development with a logically designed architecture paired with easy to understand and detailed documentation through Javadocs. The project will allow future pioneers in artificial intelligence to get their feet wet in artificial neural networks and hopefully inspire them to delve further into the topic and spark a love for computer science.
	
	Computers have had a profound effect on the development of the human race in recent years. In fact, computers are increasingly becoming irrefutably entwined with human life. Software developers have been working on improving the interfaces between computers and humans. Improved artificial intelligence makes human interactions with computers seamless and enjoyable for humans using technology. Technological advancements are also slowly replacing jobs that don't require as much skill to perform, and technology is working toward being able to do what currently only humans are capable of doing. Although not directly shown in our demonstration, the technology of artificial neural networks is increasingly being applied to the effort of trying to replicate human creativity. This seems to be the logical progression in the human interest in computers and the emerging prominent role of computation will be focused on deep machine learning.
	
\cleardoublepage
\section{TSA Plan of Work Log}
	
	Advisor signature:
	\rule{10cm}{0.4pt}
	\footnotesize
	\begin{center}
	\renewcommand{\arraystretch}{2.15}
	
	\begin{tabular} { l || p{1.25 in}| l| l|p{2.50in}}
		Date 	& Task 								& Time 	& Initials 		& Comment \\
		02/14/16 	& Research deep learning 				& 320 min	& SS, TN, CD	& Whole team is genuinely interested in the topic \\
		02/24/16 	& Research backpropagation 				& 245 min & SS, TN, CD	& Required knowledge of differential equations \\
		02/26/16 	& Compilation of research 				& 100 min	& TN, CJ		& Team gets together to discuss on whiteboards \\
		03/01/16 	& Plan development cycle 				& 70 min	& SS, TN 		& Development took longer than expected \\
		03/02/16 	& Refine development cycle	 			& 35 min	& CD, SS 		& Team reviewed development model next day \\
		03/03/16 	& Finalize design and make final revisions 	& 30 min 	& SS, TN, CD 	& Project starts later that it should have \\
		03/08/16 	& Setup git repository and review protocol 	& 65 min 	& TN, CD 		& Review protocol to ensure all team members understand commits \\
		03/12/16 	& Initial git commit						& 30 min	& TN, CD		& Included directories and auxiliary files required for functioning \\
		03/13/16 	& Plan abstract layouts					& 135 min	& SS, TN 		& More white boarding to ensure well-organized code \\
		03/15/16 	& Design Java classes					& 230 min	& TN, CD 		& Determined composition and class dependencies \\
		03/16/16 	& Begin coding framework					& 325 min	& SS, TN, CD	& First written code added to the repository \\
		03/17/16 	& Maintain code documentation				& 55 min	& TN, CD		& Keeping up with descriptive comments for code \\
		03/17/16 	& Create Java classes					& 135 min	& SS, TN 		& Creating new files to hold classes, wrote boilerplate class code \\
		03/19/16 	& Implement core methods				& 145 min	& TN, CD 		& Starting from the basics, leaving other methods unimplemented but present \\
		03/21/16 	& Create first iteration demo app			& 175 min	& SS, TN, CD	& Graphical design to communicate software capabilities to audiences \\
		03/22/16 	& Debug demonstration app 				& 105 min	& SS, TN 		& Correcting errors in programming logic for graphical UI \\
		03/23/16 	& Finalize first iteration 					& 40 min 	& SS, TN, CD	& Finish and optimize code for first project deadline \\
		03/27/16 	& Discuss redesign project 				& 55 min	& SS, TN 		& Team wished to refactor existing code drastically \\
		03/29/16 	& Plan redesign timeline					& 60 min	& SS, TN 		& It helped to plan our efforts out in great detail \\
		04/02/16 	& Start new framework 					& 140 min	& SS, TN 		& Begin coding new redesign project core \\
		04/05/16 	& Refine demo app						& 65 min	& SS, TN 		& Improve graphical interface for demo \\
		04/09/16 	& Finish redesign		 				& 150 min	& SS, TN 		& Continue coding rest of redesign project\\
		04/10/16 	& Migrate new code						& 25 min	& SS, TN 		& Switch master branch to redesign branch in Git \\
		04/13/16 	& Finalize project files					& 80 min	& SS, TN 		& Double check files and look over work for errors\\
		
	\end{tabular}
	\end{center}
	
	\normalsize
	
\cleardoublepage
\section{Software Design Process}
	\subsection{Project Requirements}
		\paragraph{Purpose}
		Ecclesia's purpose is to provide means to extrapolate an approximated function from a map of inputs and desired outputs. The software will create and evolve a neural network by training it on inputs and respective desired outputs. The design incorporates bipartite graph data structures in order to organize neuron nodes appropriately, modeling the framework after biological neural networks. The artificial neural network must be as accurate as possible.
		\paragraph{Usability}
		One of the prime requirements decided upon was the usability of our software. Usability includes the clarity and conciseness of code so that people using our software would be able to develop applications quickly and effectively. Programming the components needed to be in the style of Java so that software developers would be able to use something with which they are familiar. In order to fulfill this requirement, we preferred to make our code as logical as possible without sacrificing our reputation for creating efficient code. In addition, we were able generate Javadocs from the source code markup comments in order to greatly simplify the documentation of the code.
		
		\paragraph{Java Conventions}
		Going into our software development process, the team agreed upon using standard coding conventions when writing any portion of code for the project. Our project team used our best efforts to always write code with standard Java practices in mind, adhering to Java conventions. We were mindful of everything from proper use of whitespace, to maintaining object oriented principles in our design. Using conventions consistent with the programming language allows for readability of source code. Furthermore, using conventions allows for open source contributors to make contributions easily in order to grow Project Ecclesia. Writing with code conventions also allows for internal software development to occur at an increased rate because the whole team can agree on a universal style and everyone will be able to contribute together with the synergy of a well-trained team.
		
		\paragraph{Efficiency} 
		A major interest in our design process was in the efficiency of our software. Having an understanding of time complexity analysis and all of the basic computer science data structures such as stacks, queues, linked lists, and heaps, we knew the difference between naive code and optimized code. During the software development process, we planned out our design in abstract terms, as as we moved along further in the project, we discussed which implementations would serve us best, offering least restrictive time complexity with asymptotic analysis.
	
	\subsection{High-level Software Design}
		\paragraph{Artificial Neural Networks}
		The project is entirely based around artificial neural networks that add a layer of abstraction to the design process. This concept is a form of deep learning that is directly modeled off of the biological neural networks that are present in animals. Our design used graph data structures, filled with nodes that represented neurons. The nodes were able to interact with each other in order to form connections of influence in which neural synapses could be simulated. Nodes have multiple input nodes from which they receive data to process through a transfer function. Invoking the transfer function of a node involves the set of inputs as well as a set of numerical weights which specify each input's relative importance to a neuron. The nodes are all linked to each other going in one direction forming a directed network graph. At the other end of the graph, there are the output nodes. To generalize, inputs will enter the network and undergo processing which will yield one or more outputs. When running the network multiple times on test data, the combination of weights may not be correct the first time, so the final outputs are compared to the desired outputs and an error margin is calculated. Weights are adjusted to improve this margin (using backward propagation), and over time, the network makes less and less systematic error.
		\clearpage
		\paragraph{Modular Design}
		Ecclesia is designed to be modular so that components can be completely taken out if needed. Modular design allows for more code reuse and less boilerplate coding, allowing users to focus on what matters in their own development. Different implementations of certain data models are easily modified or swapped out for different models in order to make the software package more easily tailored to ad hoc situations. Components in Ecclesia are made so that they are easily inserted into personal projects, team collaborations, and industrial applications.
		\paragraph{Optimized Graph Data Model}
		The graph data structure that we used was as lightweight as we could possibly afford so that memory consumption would be kept to a minimum. This increased our performance in the long run and allowed us to keep the streamlined data flow model that we had earlier designed. As explained earlier, the model is that of data in constant flow. Each time the network is trained, the data flows into the graph data structure, undergoes processing, and a final output is concluded. This output is compared using metrics in order to establish error margins, and then data flows in the reverse direction to decrease the amount of error in the system. Finally, data can flow again in the forward direction in order to train the network once more.
	\subsection{Testing}
		\paragraph{Verification of Effectiveness}
		In order to test our development toolkit, we wrote a few demonstration applications in order to actually make a testament to our software's efficacy. All of our demonstrations have been neatly packaged into a demonstration launcher in order to provide an easy testing environment. 
		
		\paragraph{Point Extrapolation}
		One of the first demonstrations that we created was a very primitive point extrapolation program. An initial 2D point would be fed into the neural network and the output would be a second 2D point. The idea was that the network would be able to detect and understand patterns intuitively. The user of the application would choose an arbitrary pattern to his or her liking and continuously give the network sets of two points, with one point being the input and the other being the output. By training it on a specific pattern such as a fixed translation, or line reflection, or point rotation, the neural network would slowly be able to learn a patterned relationship between an input set of points and an output set of points. If, over time, the network becomes more and more accurate to the desired results, then the artificial neural network program can be considered effective.
		
		We discovered for that specific application of the point prediction program, our implementation of the neural network does learn over time, in fact it visibly adapts to the user's input. The results were very promising however the rate of learning did not accurately capture the beauty of neural networks. In fact, it was too slow for any of the more intricate patterns to be learned in a short enough time to capture the user's attention. Thus, we considered this inadequate for demonstrative purposes. We decided to create more demonstrations that showcased much faster rate of learning in a wide range of applications.
		
		\paragraph{Ecological Survival Simulation}
		In this next demo, we actually combined the learning of backward propagation neural networks with an optimizing genetic algorithm. It simulated the natural selection and evolution of organisms by selecting successful neural networks and disseminating their network through the simulation. Genetic algorithms are easy to implement and work on the basis of choosing models based on performance and modifying them in hope of improving their features. In this case, the models that performed the best were the ones that survived the longest and had the least error in their networks.
		
		We created a simple type of creature to model this system, calling them Malishes. The mechanics of a Malish are very simple. These heterotrophic organisms live in constant flux of satiety and famine because their health slowly reduces when they have not recently had food. In the demonstration, the color of the Malish changes from a verdant green, to a weakened yellow, and finally on the edge of its life to a desperate red as its hunger increases. In order to obtain food, each Malish has a neural network which takes the direction of the closest food particle as input and the direction that the Malish turns is based on the output of the network. Backward propagation allows this demonstration to learn extremely quickly. This demonstration, unlike the previous point predictor, worked well and users could visibly see the difference between having Ecclesia's backward propagation algorithm and without. The simulation showed that Malishes were able to exhibit efficient searching behavior in only five generations.
		
		\paragraph{Medical Datamining}
		We created more demonstrations in order to accurately showcase the panoply of applications in which Ecclesia can be used. This next demonstration uses a medical data file retrieved from the University of California, Irvine's Machine Learning Repository. It contains anonymous data from over three hundred tumor operations with information regarding the patient's age at the time of the operation, the year of the operation, information about the tumor itself, and finally their survivor status. The program is be trained on a random selection of one hundred patients from the file and the neural network will discover patterns that lead to long-term patient survival. After training the network, the user can test the network's accuracy at predicting the survival rates of one hundred more test cases that it had not previously been exposed to. In the demonstration, the user can see that the neural network picks up on a few cues to help with its survival prediction with an accuracy of greater than 70\%. A 70\% accuracy is no statistic to laud greatly, however it must be remembered that this is real medical data and does not necessarily conform to discoverable mathematical models. A greater than 70\% accuracy on real data that the neural network was not trained for shows its viability of the use of neural networks in medical research and diagnosis.
		
		\paragraph{Cancer Genetic Studies}
		On the same topic of oncology, we also took advantage of the versatility of neural networks in order to analyze sequences of nucleotides that have been known to be present in people afflicted with lung cancer. 
		
		The gene that is analyzed in this demonstration is the EGFR gene, which has been studied and determined to be a lead cause in the development of lung cancer. The EGFR gene can easily be mutated through substitution, insertion, and deletion, which makes it so prone to be oncogenes. In this demonstration we create a simulation of part of a EGFR gene where you can manipulate and mutate it through point mutations. We do this through the Voss method of mapping the nucleotides, numerical sequencing of nucleotide positions. After the gene has been manipulated, the neural network will read the Voss map, and determine whether or not the gene is carcinogenic. This though, may not be very accurate until you train the neural network to recognize the patterns of mutated genes meaning carcinogenic or non-mutated genes or otherwise non-carcinogenic through backward propagation which we have implemented a separate option for.
		This demonstration aims to show that neural networks can be used to identify sequences that will lead to harmful phenotypes. Furthermore, we really strive to show the strength of implementing backward propagation properly. Genetics is a very complex topic that requires more sophistication than regular expressions can provide.
		

		\paragraph{Digital Logic Analysis}
		This application is perhaps the most simple, but can provide limitless uses. We wanted to prove that the neural network

		
		\paragraph{Demonstration Software} In summary, we wanted to create a quick graphical demonstration of different possible applications of the Ecclesia's software as well as exemplify the effectiveness that Ecclesia can provide. Although the demonstrations are by no means a robust industrial application, they still accurately communicate the vast capabilities of Project Ecclesia. Our sole intention was to provide interactive examples of Ecclesia in use. All of the demonstrations can be found within the DemoLauncher application.
	
	\clearpage
	\subsection{End User Product Documentation}
		\paragraph{Overview}
		In our source code files, we have multiple directories. The actual neural network toolkit that we designed and implemented is located in the directory \texttt{/src/} which stores Ecclesia's core functionality. Everything needed to use Ecclesia for artificial intelligence software development is contained in this folder. Included in our source files is also the source code for our demonstrations, which are included separately in their respective directories starting with \texttt{/demo/}. For one to compile these files and run the simulations, one would need access to the files in this directory and the main source directory because the demonstrations have dependencies on the Ecclesia core packages. Further explanation of each package is detailed in the Javadocs provided.
		
		\paragraph{Javadocs Documentation}
		In order to make the end user experience as great as possible, we used Java documentation in order to make the software toolkit extremely usable. From our diligent code commenting and annotations, anyone who is new to working with Project Ecclesia will be able to use the software in their existing codebase -- anything from hobby projects to industrial applications. Using Java's built in Javadocs capability that allows HTML documentation to generated instantaneously from code, we were able to create external documentation easily. However, simply exporting our source code to Javadocs was not as simple as running a script. The content contained in the generated Javadocs originated from our code comments for every package, class, and function. The project team aimed to properly explain the logic and purpose behind every element of our software in during the development process in order to aid in the final generated documentation. In our source files, the HTML documentation is included in the folder \texttt{/docs/}. The Javadocs can be viewed as HTML files visually in any normal web browser. For this reason, in order to save paper and be environmentally sound, we have omitted the full end user product documentation in favor of using HTML.
		
\cleardoublepage		
\section{Team Evaluation and Future Prospects}
	\paragraph{Research}
	Entering the project, as we have already mentioned, we did not have the full understanding of artificial neural networks as we have now. In fact, a majority of our time allocated toward the project went into extensive research (which regrettably, there is only one page available for it in our portfolio), and we gained so much knowledge because of our genuine interest in artificial neural networks. All of us have taken advanced biology the previous year in our high school careers, and we were all excited to understand how computers could be successful at imitating real life biological systems. The research was a critical component to the correctness of our final product because it allowed us to base our development off of the architecture of real artificial neural networks used in the graduate courses of established universities. Going into the actual coding process with stable foundations in artificial intelligence gave us the ability to design a robust system that was not just a Java binding for another ANN library.

	\paragraph{Development Cycle}
	The development of Project Ecclesia has actually had two iterations to date. Our first iteration of Ecclesia had a very restrictive timeline that expected short development times and lofty goals and was completely nonpareil in terms of planning. When project team first sat down to discuss the details of our planned development cycle, we were very experienced programmers, yet lacked real experience working in a collaborative project. Our development started out with hasty planning, then as we learned to work together, we became efficient at collaboration. More time allocated to the planning of the project before it started would have helped considerably, but our whole team believes it is a valuable learning experience.
	
	\paragraph{Source Control}
	In terms of source control, we decided on using Git, and hosted our project privately on GitHub for free with a student developer license. When we were deciding what source control solution to use, we were debating between Git and SVN. Git was a wonderful solution for us because of its distributed source control which allowed us to create different development branches in order to experiment new features and track changes.
	
	\paragraph{March Redesign Efforts}
	When our project team finished with the core components of Ecclesia in late February 2016, our software toolkit was functional. However, decided that our code needed major refactoring in order to maintain the ideals of clarity and conciseness that we originally sought. We entered the slippery slope of code refactoring, and after much debate, we decided to do a complete redesign of our code base in favor of more consistent programming and improved organization.
	
	\paragraph{Coding Aesthetics}
	Our team strongly believes in the project and it has been a great time working with it to make the program function as intended. Despite our successes, we believe that it would have been even more successful if the time line of the project had been spread out over a longer period of time to allow ideas to settle and problems to be resolved with much more deliberation.
	
	\paragraph{Effectiveness}
	Through extensive testing, our team has been satisfied with the effectiveness of our artificial intelligence network's performance. We are confident in the efficiency of the design due to our preparations and planning of the software architecture. One major limitation on which our team wholeheartedly agrees is the neural network's reliance on extremely large sample data sets in order to train the network and achieve desired accuracy. However, this is a known limitation of artificial neural networks in general which has already been discussed in our research.
	
	\paragraph{Future Prospects}
	We intend for Ecclesia to grow and develop as an openly-sourced project keeping in mind our original ideals of developmental beauty derived from simplicity. After the 2015-2016 academic school year, our team plans to make Project Ecclesia's first public release, hosting the code base on GitHub. We are interested in seeing what the community can do to improve the artificial neural network toolkit. Because Java is an extremely popular programming language in the industry right now, we anticipate that our project will become popular with many users and contributors.


\cleardoublepage
\section{References and Further Readings}
	We encountered many extremely invaluable resources during our team's research which allowed us to attain a well-rounded, responsible working knowledge of artificial neural networks by the time we were finished with the project.

	\large
	\vspace{0.65cm}

	\begin{itemize}		
		\item Approximation of Functions and Their Derivatives: A Neural Network Implementation with Applications
		
			\hspace{1.5cm} University of Southern Queensland, Toowoomba, Australia
		\item Artificial Intelligence: A Modern Approach Textbook
			
			\hspace{1.5cm} Stuart Russell and Peter Norvig
		\item Caltech Machine Learning Course -- CS 156
		
			\hspace{1.5cm} Spring 2012 Video Lecture Series
		\item Derivation of Backpropagation
		
			\hspace{1.5cm} Swarthmore College, Swarthmore, Pennsylvania
		\item Evolving Neural Network Controllers for a Team of Self-organizing Robots
		
			\hspace{1.5cm} University of Klagenfurt, Klagenfurt, Austria	
		\item MIT OpenCourseWare 6.034 Artificial Intelligence
		
			\hspace{1.5cm} Fall 2010 Video Lecture Series				
		\item The Java Language Specification
			
			\hspace{1.5cm} Java SE 8 Edition, Oracle
	\end{itemize}
\end{document}          
 